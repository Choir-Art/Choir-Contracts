// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.11;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

import "../../interfaces/ITiny721.sol";
import "../../libraries/EIP712.sol";

/*
  It saves bytecode to revert on custom errors instead of using require
  statements. We are just declaring these errors for reverting with upon various
  conditions later in this contract.
*/
error CannotMintInvalidSignature();
error SweepingTransferFailed();

/**
  @title A contract which accepts signatures from a trusted signer to mint an
    ERC-721 item in exchange for payment in some ERC-20 token.
  @author Tim Clancy
  @author Rostislav Khlebnikov

  This token contract allows for the implementation of off-chain systems that
  mint items to callers using entirely off-chain data.

  March 6th, 2022.
*/
contract ClaimableMint is
  EIP712, Ownable, ReentrancyGuard
{
  using SafeERC20 for IERC20;

  /// A constant hash of the mint operation's signature.
  bytes32 constant public MINT_TYPEHASH = keccak256(
    "mint(address _minter,uint256 _cost,uint256 _offchainId)"
  );

  /// The name of this minter.
  string public name;

  /// The address permitted to sign claim signatures.
  address public immutable signer;

  /// The address of the ERC-20 token to accept minting payment in.
  address public immutable token;

  /// The address of the Tiny721 item to mint new items into.
  address public immutable item;

  /// The address where all `token` payments are sent to.
  address public immutable paymentDestination;

  /**
    This mapping allows the `item` contract to be the sole controller of the
    token ID space while still allowing us to correlate sequentially-minted
    items with an ID for off-chain data look-up. That is, whenever an item is
    minted, it will be given the next ID in the item's sequence such that the
    on-chain ID space is not gappy. However, we might want to correlate that
    item to off-chain data that has already been pre-generated with a different
    ID. The most obvious use-case for this is the ascension of off-chain items.
  */
  mapping ( uint256 => uint256 ) id;

  /**
    An event emitted when a caller mints a new item.

    @param timestamp The timestamp of the mint.
    @param caller The caller who claimed the tokens.
    @param id The ID of the specific item within the ERC-721 `item` contract.
    @param offchainId The ID of any off-chain resource mapped to the item as a
      part of this mint.
    @param cost The cost of the mint in `token`.
  */
  event Minted (
    uint256 timestamp,
    address indexed caller,
    uint256 id,
    uint256 offchainId,
    uint256 cost
  );

  /**
    Construct a new minter by providing it a permissioned claim signer which may
    issue claims and claim amounts, the payment token, and the item to mint in.

    @param _name The name of the vault used in EIP-712 domain separation.
    @param _signer The address permitted to sign claim signatures.
    @param _token The address of the ERC-20 token used to pay for mints.
    @param _item The address of the Tiny721 contract that items are minted into.
    @param _paymentDestination The destination address that all `_token` minting
      payments are sent to.
  */
  constructor (
    string memory _name,
    address _signer,
    address _token,
    address _item,
    address _paymentDestination
  ) EIP712(_name, "1") {
    name = _name;
    signer = _signer;
    token = _token;
    item = _item;
    paymentDestination = _paymentDestination;
  }

  /**
    A private helper function to validate a signature supplied for item mints.
    This function constructs a digest and verifies that the signature signer was
    the authorized address we expect.

    @param _minter The caller attempting to mint a new ERC-721 item.
    @param _cost The cost in the ERC-20 `token` required to complete this mint.
    @param _offchainId The ID of off-chain data that should be related to the
      on-chain ID of the new item that gets generated by this mint.
    @param _v The recovery byte of the signature.
    @param _r Half of the ECDSA signature pair.
    @param _s Half of the ECDSA signature pair.
  */
  function validMint (
    address _minter,
    uint256 _cost,
    uint256 _offchainId,
    uint8 _v,
    bytes32 _r,
    bytes32 _s
  ) private view returns (bool) {
    bytes32 digest = keccak256(
      abi.encodePacked(
        "\x19\x01",
        DOMAIN_SEPARATOR,
        keccak256(
          abi.encode(
            MINT_TYPEHASH,
            _minter,
            _cost,
            _offchainId
          )
        )
      )
    );

    // The claim is validated if it was signed by our authorized signer.
    return ecrecover(digest, _v, _r, _s) == signer;
  }

  /**
    Allow a caller to mint a new item if
      1. the mint is backed by a valid signature from the trusted `signer`.
      2. the caller has enough `token` to pay the minting cost.

    @param _cost The cost in the ERC-20 `token` required to complete this mint.
    @param _offchainId The ID of off-chain data that should be related to the
      on-chain ID of the new item that gets generated by this mint.
    @param _v The recovery byte of the signature.
    @param _r Half of the ECDSA signature pair.
    @param _s Half of the ECDSA signature pair.
  */
  function mint (
    uint256 _cost,
    uint256 _offchainId,
    uint8 _v,
    bytes32 _r,
    bytes32 _s
  ) external {

    // Validiate that the claim was provided by our trusted `signer`.
    bool validSignature = validMint(
      _msgSender(),
      _cost,
      _offchainId,
      _v,
      _r,
      _s
    );
    if (!validSignature) {
      revert CannotMintInvalidSignature();
    }

    // Charge the caller the mint price.
    IERC20(token).safeTransferFrom(
      _msgSender(),
      paymentDestination,
      _cost
    );

    // Mint the new item.
    ITiny721 itemContract = ITiny721(item);
    itemContract.mint_Qgo(_msgSender(), 1);

    // Update the mapping of on-chain item ID to the supplied off-chain ID.
    uint256 newId = itemContract.totalSupply();
    id[newId] = _offchainId;

    // Emit an event.
    emit Minted(block.timestamp, _msgSender(), newId, _offchainId, _cost);
  }

  /**
    Allow the owner to sweep either Ether or a particular ERC-20 token from the
    contract and send it to another address. This allows the owner of the shop
    to withdraw their funds after the sale is completed.

    @param _token The token to sweep the balance from; if a zero address is sent
      then the contract's balance of Ether will be swept.
    @param _amount The amount of token to sweep.
    @param _destination The address to send the swept tokens to.
  */
  function sweep (
    address _token,
    address _destination,
    uint256 _amount
  ) external onlyOwner nonReentrant {

    // A zero address means we should attempt to sweep Ether.
    if (_token == address(0)) {
      (bool success, ) = payable(_destination).call{ value: _amount }("");
      if (!success) { revert SweepingTransferFailed(); }

    // Otherwise, we should try to sweep an ERC-20 token.
    } else {
      IERC20(_token).safeTransfer(_destination, _amount);
    }
  }
}
